# 为什么用B+树
1. 链表
    查询效率O(N)
2. 数组
    二分查找的复杂度O(log<sub>2</sub>N)，但是插入和删除元素的效率很低，O(N)
3. 平衡二叉树AVL
    左右子树的高度差不超过1；
    查询的时间复杂度O(log<sub>2</sub>N)，查找效率为深度有关；但是在做插入和删除操作时，需要多次旋转达到平衡；适应于对查询多的场景；
4. 红黑树RBT
    前提：AVL
    节点有红色和黑色，是一种弱的AVL，根节点到叶节点的最长路径不超过最短路径的2倍；时间复杂度O(log<sub>2</sub>N),但是最坏的时间复杂度差于AVL；插入和删除操作可以经过较少的旋转操作达到平衡，一般在内存中使用，如HashMap，TreeMap等；
    在进行平衡处理时，由于红黑树非严格平衡(不要求左右子树深度差1)，而且可以采用变色操作达到平衡(变色时间复杂度在O(logN)数量级上)，速率要快于AVL。
    当插入一个节点时，AVL和RBT都最多需要2次旋转操作，但是删除节点引起不平衡时，AVL最多需要logN次旋转操作(影响根节点)，而RBT最多只要3次，代价要低很多。
5. B树和B+树
    前提：多路查找树
    索引是存在磁盘的文件中的，通常索引会很大，无法一次性将全部索引加载的内存中，因此，只能每次从磁盘读取一个磁盘页的数据到内存中；
    AVL树，逻辑上是平衡二叉树，但是底层是数组实现，逻辑结构上相近的节点在物理结构上可能相差很远（一个节点一个页，深度大，页太多？），那么无法用到磁盘预读的功能(局部性原理：当用到某个数据时，其附近的数据马上也会被用到，因此，从磁盘中读取数据时，会预读一定长度的数据放入内存，通常为页的整数倍；磁盘顺序读写效率很高--不需要寻道时间，只需要很少的旋转时间)，因此查找过程中需要更多的磁盘IO；
    B树充分利用了磁盘预读的功能，每个节点有多个子节点，将节点大小设置为磁盘页的大小，每次读取磁盘页时会读取一整个节点；树的深度很小，磁盘IO次数也少了很多；（树的深度就是磁盘IO的次数）=== 每次新建节点时，直接申请一个页的大小，这样就能保证一个节点在物理上也存储在一个页中。
    B树是有序数组+平衡多叉树；B+树是有序数组链表+平衡多叉树；
    B+树的非叶子节点只存储索引，叶子结点存储索引+数据；而B树的叶子和非叶子结点都是用存储了数据+索引；即B+树的非叶子结点相对B树要小。如果把同一个内部结点的关键字(索引或数据)放在一个磁盘块中，那么盘快能够容纳的关键字数量也更多，一次性读入内存中的需要查找的关键字也越多。相对来说，IO读写次数降低了。(假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。内存中也能够存放更多的key)
    B+树的叶子结点通过指针互相连接，提高了区间访问的性能，范围查询非常方便，不用像B树一样需要再次从根节点进行遍历；B+树方便扫库，直接从叶子结点挨个扫一遍就完了，而B树必须用中序遍历的方法按序扫库；B+树的查找稳定性更好，每次都是查询到根节点结束；B树的优点是成功查询特别有利，因为树的高度比B+树矮，不成功的情况下，B树也比B+稍占一点便宜。有很多基于频率的搜索选用B树，越频繁的query的节点越往根上走，前提是需要对query进行统计，并对key做一些变化；（不需要到叶子结点就可以查到数据，而且靠近根节点的几层由于频繁查询，这几块基本在内存中，不会有磁盘IO，在启动的时候进行进入内存）
    B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。
    
    [B+树为什么适合做索引](https://blog.csdn.net/weixin_30531261/article/details/79312676)
    [索引背后的数据结构](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)