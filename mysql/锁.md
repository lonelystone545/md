[TOC]
# 参考
[https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html](https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html)
# 分类
mysql锁分为全局锁、表锁和行锁
* 全局锁
FTWRL命令，只允许读，不允许改，主要用来备份使用；如果不加锁，那么备份得到的数据不是同一个时间点；对于innodb来说可以采用事务保证拿到视图的一致性，mysqldump工具在导出数据前就会启动一个事务。
* 表锁
包含表锁和元数据锁  lock tables … read/write
    表锁：读写互斥，写写互斥，读读不互斥
    元数据锁：在访问一个表的时候自动加上，读读不互斥，读写/写写互斥；用来保证变更表结构操作的安全性
* 行锁
   是由各个存储引擎自己实现的，myisam不支持行锁。innodb支持行锁，更好的并发性。
   
## 记录表/间隙锁/临键锁
[MySQL的锁机制 - 记录锁、间隙锁、临键锁](https://zhuanlan.zhihu.com/p/48269420)
记录锁：为某行记录加锁，会锁住该行的索引记录；当查询语句中是主键或唯一索引时，且必须为精确匹配(=)时才会加记录锁，否则会加临键锁。（如果记录不存在，此时也会加间隙锁）
间隙锁：基于非唯一索引，会锁定一段范围内的索引记录。会根据查询条件，向左和向右找到靠近的值作为左右开区间，然后锁住这个区间的记录。（数据间隙的分析，数据行优先根据普通索引排序，再根据唯一索引排序，决定会不会被阻塞。按照这样说，非唯一索引的精确查找时是需要加间隙锁的，如果插入相同的值，那么会先按照普通索引排序再按照唯一索引排序，那么可能在前后）
临键锁：解决幻读问题。InnoDB的默认加锁方式是next-key 锁。
   
   
# delete from where key
如果key是主键或者唯一索引，则锁行；如果是普通索引，且该字段重复率低，则锁行，否则行锁会升级为表锁；（重复率高的字段，加索引不起效果）

# insert加的锁
对于update或者delete，如果记录存在，则会在记录上加排他锁或者间隙锁或者升级为表锁，那对于insert呢？记录本身不存在，如何加锁呢？
在insert数据前，会先加 插入意向锁，注意该锁不是意向锁，而是属于间隙锁，插入意向锁和插入意向锁之间互不冲突，所以在一个间隙中可以有多个事务同时插入不同索引的记录，即允许多个事务同时插入一个间隙不同位置的记录，不会被锁住。但是插入意向锁和间隙锁冲突，间隙锁的目的是防止幻读，因此在insert的时候需要先加插入意向锁，由于插入意向锁和间隙锁冲突，所以需要阻塞等待，否则，如果不加插入意向锁，那么insert就会成功，出现了幻读。
这里用的是插入意向锁，而不是直接用间隙锁，为的是提高插入的并发性，当插入一个间隙的不同位置时，可以并发插入。
在数据插入完成后，才会加索引记录锁（排他锁），也就是说，如果不加插入意向锁，是没办法直接索引记录锁的，因为记录都还不存在。
   
# 可重复读如何实现
核心就是一致性读，通过MVCC，读的是快照数据，而不是当前数据；而事务更新的时候，只能用当前读，也就是说，如果当前记录的行锁被其他事务占用，那么需要进入锁等待。(两阶段协议)
可重复读时，是在事务开始的时候创建一致性视图(MVCC快照数据)，之后事务里的其他查询都共用这个视图；而读已提交时，是在每一个语句执行前都会重新算出一个新的视图。   


# 两阶段锁
   两阶段锁协议：在一个事务中，分为加锁和解锁阶段，所有的lock操作均在unlock之前，只有在需要的时候才会加锁，在事务提交或者回滚时才会释放锁；因此，需要把最热点的记录放到事务的最后，这样可以减少锁的持有时间，提高吞吐量。
   存在的问题--死锁，获取锁的顺序不同

    
# Online DDL
1. 拿MDL写锁
2. 降级成MDL读锁
3. 真正做DDL
4. 升级成MDL写锁
5. 释放MDL锁
1、2、4、5如果没有锁冲突，执行时间非常短。第3步占用了DDL绝大部分时间，这期间这个表可以正常读写数据，是因此称为“online ”