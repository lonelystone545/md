[TOC]
# Question
1. redo log重做日志/binlog 为什么double write
2. mysql大事务
3. mysql 事务实现原理
    https://juejin.im/post/5cb2e3b46fb9a0686e40c5cb
    通过mvcc解决了可重复读问题；通过间隙锁和next-keys解决了幻读问题
4. mysql架构(多master)

# 数据库一致性的理解
https://www.zhihu.com/question/31346392

# sql执行顺序
1.  FROM 子句 组装来自不同数据源的数据
2.  WHERE 子句 基于指定的条件对记录进行筛选
3.  GROUP BY 子句 将数据划分为多个分组
4.  使用聚合函数进行计算
5.  使用HAVING子句筛选分组
6.  计算所有的表达式
7.  使用ORDER BY对结果集进行排序
8.  select 获取相应列
9.  limit截取结果集

# 主键的选择
1. 主键的长度不要太长，如uuid，因为辅助索引的叶子结点会存储主键，会导致辅助索引树很大；
2. 数字比字符串更合适，数字的比较速度快；
3. 字符串作为主键时，尽量避免无序；
4. 如果业务上有作为主键的列，是字符串类型，也可以选为主键；

# 索引优化
优先对where和order by的条件建立索引；
## 哪些情况下无法用到索引
1. 数据类型为text和blob等大对象不能建立索引，会使索引树太大，而且可能无法放入内存，带来更多的磁盘IO，效率低；
2. 查询条件上的索引项上带有函数，如date(create_time)>''，此时无法使用索引；但是右边的值可以使用函数，如create_time<now()，这样可以走索引查询；
3. 一次查询只能使用一个索引；where c1 = and c2 = order by c3;如果c1和c2分别建立了索引，那么mysql会选择一个执行效率高的索引进行查询；可以对索引进行优化，如使用联合索引(c1,c2,c3)；在order by时尽量和where使用一个索引项。
4. 选择率低的列不适合建立索引；mysql会执行自己的查询计划，选择走索引还是全表扫描，因为走索引的话，首先需要访问索引文件，拿到叶子结点的主键，然后再回表查询，如果结果集比较大，这个代价可能大于全表扫描，因为全表扫描（按照主见的顺序）是顺序IO，走索引的话是随机IO；
5. 过多的索引会给更新操作带来更沉重的维护代价，需要更新索引树；而且索引太多，那么mysql在生成执行计划时也需要考虑更多的索引，给查询优化带来更多的工作。
6. Order By ,Group By 可以利用索引避免排序。但是 存在where 语句下 只能使用where 查询中使用的索引，例如where中使用了(A,B，C,D)联合索引的A,B项，如果order by ,或者group by中存在C，或者(C，D)即可使用联合索引，如果where中没有使用索引，那么即使order by,group by列中有索引也不能使用。即优先根据where 查询使用索引，然后根据where中使用的索引再决定，order by,group by是否可以 使用到索引；
7. 数据量达到千万级别时，索引本身就很大，无法装入内存，访问索引带来的随机IO开销很大，索引性能下降，可以建立分区表，因为分区表的索引结构是互相独立的，可单独装入内存，减少磁盘访问；
8. 模糊匹配查询时，like "12%"可以使用索引，但是like "%12"是无法用到索引的；
9. 查询条件有or，那么or条件中的每个列都必须有索引，否则失效；
10. 利用覆盖索引，避免回表查询；
11. 联合索引需要走最左前缀原则；
12. 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。>或者<则mysql会根据查询计划决定是否走索引还是全表查；
13. 数据类型出现隐式转换的时候不会走索引，比如字段类型是字符串，但是查询时给的是整型，那么不会走索引，必须用引号引起来。
14. 负向条件不会走索引，如not in，!=，not exists等，可以优化为in查询；对于not in的优化，可以优化为left join，然后右表的条件列is null进行过滤；![](media/15668213611880.jpg)
15. 一般，索引列不允许为null，is null走索引，但是is not null无法走索引；
16. 范围查询可能会走索引，如in,between,>,<等，但是如果in的条件列中选择性比较低，那么可能不会走索引，或者in数据量比较大的时候也不会走索引；
17. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

## 索引设计技巧
1. 更新频繁的字段不适合建立索引；
2. 选择率低的字段不适合建立索引；
3. 索引的选择应该跟业务需求有关，前期不能建立太多的索引，要根据业务进行取舍；
4. 尽量建立短的索引，索引长度不宜过大；
5. 联合索引的顺序问题，优先将选择率高的列作为联合索引的第一列，这样第一列可以过滤更多的列，效率高；而且联合索引的第一列可以单独使用；
6. group by,order by 本质是对where查询出的结果集进行排序操作，当待排序列匹配 where 中索引顺序时才可避免排序，直接通过索引即可返回有序结果集，例如我们需要将查询结果按照评分排名，那么就可以考虑将rank列放在联合索引的最后一列。(X, …… ,rank)。当查询结果比较大时，可以考虑这样设计。
7. limit 分页查询 .limit 使用时必须排序否则可能出现不同页返回重复数据的风险。limit 返回某一位置的给定偏移量的记录，但是它的顺序依赖于存储位置顺序，索引顺序，所以分页时不同页会有出现重复数据的风险。limit 操作前需要添加order by 进行排序。由于访问非聚簇索引时，mysql有一个优化操作，当访问非聚簇索引，回表查询时，mysql 会对主键进行排序，目的是：聚簇索引是按顺序存储记录，对主键排序后，访问聚簇索引可以更加顺序的访问磁盘，减少随机I/O，提高速度，所以当分页没有特别指定的列时，指定主键排序即可，另外不需要在联合索引最后一列添加主键，因为它本身包含主键 【非聚簇索引不存储完整记录，通过访问主键索引找到完整记录 】。
8. 如果要对字符串很长的列建立索引，可以考虑单独增加索引列，对整体或者部分hash后存入其他的列，这样字符串查找变成数字查找，同时索引长度大大减小，有效提高索引速度，降低索引大小，需要考虑hash冲突问题，选择合适的hash函数；







# mysql innodb为什么推荐使用自增主键
mysql索引的底层结构是采用B+树实现，myisam来说，叶子结点存放的是数据记录的地址，叫非聚集索引；innodb来说，主键的B+树的叶子结点存放的是数据记录，这种索引叫聚集索引。聚集索引也就是，数据的物理结构顺序和逻辑结构顺序是一致的。innodb数据文件本身按照主键聚集，所以innodb表要求必须有主键（myisam可以没有）。如果没有显示指定，则mysql会自动选择一个唯一索引作为主键；如果不存在这样的列，则mysql会自动为innodb表生成一个隐含字段rowid作为主键，6个字节，长整型。聚集索引的实现方式使得按照主键的搜索十分高效，但是辅助索引需要检索两遍。
如果主键过长，因为辅助索引会在叶子结点引用主键索引，那么会使辅助索引也变得很大。
innodb聚集索引要求同一个叶子结点内（大小为一个磁盘页）的各条数据记录按照主键顺序存放，因此每当有一条新记录插入时，mysql会根据主键将其插入适当的位置，如果页面达到装载因子（innodb默认15/16），则会开辟一个新的页（结点）。
如果采用自增主键，那么每次插入新记录时，记录会按照顺序添加到当前索引结点的后续位置，当一个页写满，会自动开辟一个新的页。这样会形成一个紧凑的索引结构，近似顺序填满，而且不需要移动数据，效率很高。如果是非自增主键，由于每次插入主键的值近似随机，因此每次新记录都要被插到现有索引页的中间某个位置，那么必然需要移动其他数据，甚至目标页面可能已经被回写到磁盘而从缓存中清掉，此时又要从磁盘上读回来，增加很多IO开销，同时频繁的移动/分页操作造成了大量的碎片，得到了不紧凑的索引结构，后续不得不通过optimize table来重建表并优化填充页面。

[为什么推荐采用自增主键](https://www.kancloud.cn/db-design/mysql-dba/596722)

# 自增主键用完了如何处理？
int-43亿多   可以采用bigint，基本不会用完。 ==》 引入 如何变更字端的类型，锁表？
另，一般来说，当表中的数据超过亿后，就需要考虑分库分表了。

[自增主键用完了怎么办](https://www.cnblogs.com/rjzheng/p/10669043.html)
[分库分表如何部署上线](https://www.cnblogs.com/rjzheng/p/9597810.html)

# 分库分表？？？？
分库提高并发性能；分表提高查询效率；

# mysql线程池
[mysql线程池](https://dbaplus.cn/news-11-1989-1.html)
mysql是单进程多线程模型；
当DB的并发访问大到一定程度时，DB的吞吐量会出现下降，这是为啥----默认是采用一个连接创建一个线程处理，线程太多，上下文切换多，竞争也多了。
为了解决 一个连接一个线程 存在的频繁创建和销毁大量线程以及高并发情况下DB雪崩问题，实现DB在高并发环境中依然保持较高的性能，推出了 线程池。
1、threadpool中worker线程处理单位为一个statement，而不是one-thread-per-connection对应的一个连接；当worker线程处理完A连接发送来的一个sql后，A连接没有立刻发送第二条sql，worker线程回去服务其它连接发送来的sql，因此worker线程工作效率更高，系统需要的线程数也更少 
2、threadpool本质上是一个生产者-消费者模型，为了减小竞争，threadpool被划分为N个group（n默认为cpu核心数），连接发送的sql根据连接id分配到不同的group中，因此，同一个连接发送的所有sql是被同一个group中的worker线程处理的 
3、每个group都有2个任务队列， 即优先队列和普通队列 ，如果一个sql所在的事务已经开启，则将任务放到优先队列中，否则放到普通队列中，worker线程优先从优先队列中取任务执行，当优先队列为空则从普通队列取任务执行，这个可以保证已经开启的事务优先得到执行，从而尽早释放其占用的资源（主要是锁），可以有效减小响应时间，别且避免调度上的死锁（A和B被分到不同的group中，A事务已经开启，并且获得了锁，可能无法立即得到调度执行，B事务依赖A事务释放锁资源，但是先于A得到调度） 
4、每个group中每个worker线程地位一样，如果遇到任务队列为空的情况，线程会调用epoll_wait批量取任务 
5、threadpool额外创建了一个timer线程，每隔一段时间检查一遍所有的group，如果发现group出现异常（堵塞/超时/worker线程数目不够），及时唤醒线程


# 数据库为什么不采用NIO的网络模型
数据库的客户端还是维护连接池的概念，采用的BIO模型；数据库的瓶颈是磁盘IO，而网络通讯不是瓶颈，因此在通讯协议上做优化，性能提升并不明显。
而且，既然IO是瓶颈，如果采用了NIO，那么会有更多的连接，这会增加IO的负担；（使用NIO为了就是充分利用CPU的资源，而不是处于阻塞状态，而mysql本身就是一种cpu密集型的(慢查询会导致cpu飙高)）