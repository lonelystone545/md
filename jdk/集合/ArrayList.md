# 基本点
1. 实现了List/Cloneable/Serializable/RandomAccess接口
2. 初始化容量是10；采用无参构造时，实际上是一个空数组，当第一次添加数据时，数组进行扩容，调用ensureCapacityInternal方法，将容量变为10；
3. 调用trimToSize方法能够将数组缓冲区大小调整为实际ArrayList存储元素的大小，减少空间资源的浪费；底层调用Arrays.copyOf(elementData, size)方法==System.arraycopy()创建新的数组，数组之间进行copy
4. modCount作用：fail-fast机制，在增加和删除元素时改变该值，修改和查询不会；
5. 底层是数组，占据一块连续的内存空间，长度就是数组的大小，查询O(1)，添加/删除O(N)；
6. 当集合中元素个数超出数组长度时，数据会进行扩容操作，比较耗时，如果能够预知数据量大小，最好能够指定容量，减少扩容次数，提高写入效率；
7. 在add元素时会判断是否需要进行扩容，如果元素数量大于数组长度，则扩容至新的数组长度为原来数组长度的1.5倍，如果扩容后还不够，那么就用目标size作为扩容后的长度(对于添加一个集合的元素可能出现)。然后调用Arrays.copy方法拷贝数据内容，最后添加元素；
8. Iterator迭代器，返回内部类Itr实现了Iterator接口，类内部维护了一个游标cursor，表示当前的的位置；在迭代前会拿到modCount的值，每次调用next/remove方法时都会校验该值是否发生改变，如果变化了则快速失败，并发修改异常；