# 基本知识
1. 跳表是一种随机化的数据结构，LevelDB和Redis底层的数据结构有用到；
2. 跳表采用的是空间换时间的算法；插入/查找/删除的时间复杂度为O(logN)，跳过某些节点进行查找，数据天然有序，但是常数项比红黑树大；
3. 如果要实现一个key-value结构，需要的功能有插入/查找/迭代/修改，首先hash表不适合，因为迭代的时间复杂度比较高；而红黑树的插入可能涉及多个节点的旋转/变色，需要加锁处理，降低了并发度；skiplist底层是用链表实现，可以实现无锁，单线程情况下只比红黑树略慢，非常适合实现key-value结构。
4. 跳表在插入元素时，采用随机过程来决定一个元素的级数；
5. 跳表有很多层组成；每一层都是一个有序链表；每一层任意一个节点，不仅有指向下个节点的指针，也有指向下一层的指针；层数是通过随机算法得到的，1/2，抛硬币；

# 跳表缺点
1. 内存占用比红黑树大，跳表的每个节点不仅仅包含指向下一个节点的指针，还有可能包含很多个指向其他后续节点的指针；（引用占4个字节）

# 结构演进
数组的查询时间复杂度O(1)，但是插入和删除元素的复杂度为O(N);链表的查询时间复杂度为O(N)，插入和删除的时间复杂度O(1)；AVL(红黑树)树的增删改查的效率为O(logN)，但是AVL的实现一般比较复杂，而且插入和删除元素时可能会对整个树的结构进行修改，特别是并发环境下，通过需要全局锁来保证线程安全；因此出来了类似链表的数据结构-跳表。

# 跳表和其他数据结构的比较
散列表的插入和查询操作都是O(1)，最坏情况下是O(n)，且是无序的；跳表是自然排序的，插入和查找的复杂度为O(logN)；如果经常需要迭代并且要求有序的时候，使用跳表只需要沿着最底层进行遍历就可以升序输出所有元素，而散列遍历出来后，还需要进行排序；

skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。
在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。
平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。
从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。
查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。
从算法实现难度上来比较，skiplist比平衡树要简单得多。

# 参考
[redis为什么采用skiplist而不是红黑树](https://zhuanlan.zhihu.com/p/23370124)
