# 作用
1. 保证内存可见性，被volatile修饰的变量，会让工作内存中缓存的变量失效，java线程每次都需要从主内存中读取数据，并且写完该变量后必须强制刷新回主内存。
2. 禁止指令重排序。重排序是编译器或者cpu对执行效率的优化，通过改变代码指令的执行顺序，提高执行效率。比如先操作a变量，后操作b变量，此时a在同步代码块中，线程可能会先执行b变量，而不是立即阻塞。重排序要求 不能影响单线程的执行结果；对于有依赖关系的变量是不能进行重排序的。  在多线程下，重排序可能会产生一些问题。如线程A执行int a=1;boolean flag=true;线程B执行while(flag) a=a+1；那么线程A可能重排序，即先执行flag，此时b拿到的是a，执行a+1操作，最终a等于1了，而结果应该等于2；

# 线程安全的单例为什么要volatile修饰
采用双重检查加锁的情况下，对象需要用volatile修饰。
问题出现在new Singleton()时，首先会检查class对象是否加载，如果没有则加载class对象，然后分配内存空间，初始化实例对象，再调用构造函数实例化对象，最后返回地址给引用；但是cpu可能为了优化进行重排序，先将地址返回给引用，然后再调用构造函数进行实例化，此时如果有另外一个线程来获取实例对象，发现不为null，则直接返回引用了，那么这个线程就使用了还没被初始化的变量。
加了volatile之后，就保证new 不会被指令重排序。