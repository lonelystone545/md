[TOC]
# 参考
[主要参考](https://segmentfault.com/a/1190000015807573)
# 简介
通过ReentrantLock分析了AQS的独占锁功能，这里通过CountDownLatch分析AQS的共享锁功能。
CountDownLatch是一个计数器，当计数器减少到0的时候，多个线程可以触发后续的操作。通过await方法阻塞，countDown方法减1。通过该类，可以使多线程达到最大的并行度。不能被重复使用。
共享功能的结点，一旦被唤醒，会向队列后部传播（Propagate）状态，以实现共享结点的连续唤醒。这也是共享的含义，当锁被释放时，所有持有该锁的共享线程都会被唤醒，并从等待队列移除。
AQS不关心state具体是什么，含义由子类去定义，子类则根据该变量来进行获取和释放的判断，AQS只是维护了该变量，并且实现了一系列用来判断资源是否可以访问的API，它提供了对线程的入队和出队的操作，它还负责处理线程对资源的访问方式，例如：什么时候可以对资源进行访问，什么时候阻塞线程，什么时候唤醒线程，线程被取消后如何处理等。而子类则用来实现资源是否可以被访问的判断。
# 源码
## new CountDownLatch(number)
内部类继承了AQS类，并将number值赋值给同步状态的值state；在CountDownLatch中，同步状态state表示计数器的初始大小。
<br><font size='2'>在CountDownLatch中，同步状态State表示CountDownLatch的计数器的初始值，当State == 0时，表示无锁状态，且一旦State变为0，就永远处于无锁状态了，此时所有线程在await上等待的线程都可以继续执行。
而在ReentrantLock中，State==0时，虽然也表示无锁状态，但是只有一个线程可以重置State的值。这就是共享锁的含义。</font>
## await()
支持响应中断的。调用AQS的acquireSharedInterruptibly(1)方法。
1. 尝试获取共享锁，即如果state==0则获取锁成功，否则返回失败；
2. 获取成功则直接放行；失败则以共享锁模式进入等待队列；将当前线程封装为Node结点，共享锁模式（nextWaiter指向空结点，只是一个标记作用，判断是否处于共享模式）进入队列尾部，自旋尝试获取锁或者进行阻塞挂起线程结点；
3. 线程被唤醒后，会根据传播状态和waitStatus<0和结点是否处于共享模式决定是否对后继结点进行唤醒；每一个唤醒的线程都会执行这个操作；


## countDown()方法
1. 释放锁，将同步器状态state减1，如果state首次变为0，则会进行唤醒线程的操作，即步骤2；
2. 唤醒head结点的后继结点，即等待队列中的首个线程，unPark操作；
到这里，countDown方法基本结束了，这里只是唤醒了一个线程，其他线程的唤醒是由其上一个线程结点唤醒后会根据传播状态(这里是1,获取锁成功)即waitStatus决定是否对其后继结点进行唤醒。

