[TOC]
# 参考
[源码解析](https://juejin.im/entry/57538d197db2a20069856e0b)

# 问题
## 为什么双轴快排会比较快
参考[为什么双轴快](https://www.jianshu.com/p/2c6f79e8ce6e)
如何说明一个排序算法快慢呢？传统来说，就是元素之间的比较次数。但是，如果只是从比较次数来看，双轴快排比较的次数比单轴快排要多很多。
因为现在的CPU运算速度很快，所以单独看比较次数没什么意义，瓶颈不是在CPU，而不是在内存上，所以作者提出了一种“扫描元素次数”更能体现当前计算机里面的性能指标。
但是对于同一个下标，并且对应的值也不变得话，即使访问多次我们也只算一次。
而且，双轴快排减少了递归的次数。
# Arrays.sort(int[] a)
## 基本思路
1. 如果数组长度小于插入排序阈值47，则采用插入排序；（数据比较少时，插入排序性能优于快排）
2. 如果数组长度大于插入排序阈值，但是小于快速排序的阈值286，则采用改进后的双轴插入排序；
3. 否则，判断数组是否基本有序；通过将数组划分为不同的有序序列，如果有序序列的个数大于67，则认为是基本无序，则仍然采用双轴快速排序，否则，则认为数组基本有序，则使用归并排序进行排序。（归并排序对于合并两个基本有序序列的效率很快）

## 插入排序
通过leftmost控制采用传统的插入排序还是改进的插入排序，改进的插入排序被称为 成对插入排序，基本思想是一次取出两个未排序数组的元素，并且确保a1>a2，那么a1找到位置后，a2肯定在a1之前，继续查找即可。这样较小的元素不必再走一遍较大元素走过的路，如果元素个数为奇数，则最后一个元素单独进行一次排序。
[成对插入排序](https://www.jianshu.com/p/98539ba3fd86)

## Dual-Pivot QuickSort双轴快排
[参考快排优化-很详细](https://blog.csdn.net/Holmofy/article/details/71168530)
双轴快速排序的思想是相对于单轴快速排序，经典的单轴快速排序，每次选择一个元素作为轴值pivot,然后使用双指针将小于pivot移到pivot的左边，大于pivot的值移到右边，使得pivot处于最终位置，这个过程称为一次排序，对两边递归的调用一次排序可以得到最终的排序结果。
而双轴快速排序的基本思想是一次可以将两个元素放到最终位置上，假设这两个轴值为pivot1,pivot2,那么一次排序后，最终数组被这两个元素划分成三块：<pivot1, >=pivot1并且<=pivot2, >pivot2。为了达到这种划分，我们需要三个指针来进行操作i,k,j,i左边的是小于pivot1的，j右边的是大于pivot1的，k用来扫描，当k和j相聚的时候，则扫描结束。

* 如何选取双轴呢？
    jdk中通过选取五分位点，当所有值都不相同时，选取第二个和第四个作为双轴，否则就使用第三个点作为单轴。


# Arrays.sort(Object[])
## 基本思路
1. 如果数组元素个数小于MIN_MERGE(32)，会调用二分插入排序binarySort方法进行排序，所谓二分排序，是指在插入的过程中，使用二分查找的方法查找待插入的位置，这种查找方法会比线性查找快一点。
2. 如果大于MIN_MERGE，则将数组划分成多个有序块进行归并排序。归并的方法是将数组换分成等块的小数组(除最后一块)，在小数组内进行二分插入排序，排序后将当前数组的初始位置，长度使用pushRun方法压栈，mergeCollapse方法每次会从数组中取出两个小数组进行归并排序，最终循环结束后，数组也已经排序完成。
