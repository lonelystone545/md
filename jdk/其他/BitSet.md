BitSet是进行位操作的对象，值只有0或者1，内部维护了一个long数组。之所以用long而不是byte或者int，是因为long占用8个字节64位，某些方法（如and/or）在对数组进行遍历时，遍历的元素也是最少的。

对位的操作，比如第N位，则在数组中的位置为N/64的元素的N%64的位。
[参考这里把](https://blog.csdn.net/caiandyong/article/details/51581160)

BitSet只能接收数字类型，对于string类型，只能使用hashcode；那么如何解决hash冲突呢？
1. 使用多个hash函数，对多个bit位进行 赋值，当判断是否存在时，只有这些位置都是true时才表示存在。（类似布隆过滤器，有一定的误判）
2. 依然采用多个hash函数，但是每个hash函数算法对应一个BitSet，降低冲突概率；依然可能存在误判；
3. 其实没办法完全避免误判，除非将原来的数据保存下来，采用链表法解决hash冲突，但是又违背了使用BitSet的初衷；海量数据的场景，一般来说，会允许存在一定的误差；