[TOC]
# 概念
Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。
几乎所有的框架能够提供的一些自动化机制都是靠反射实现的，这也是为什么各类框架都不允许你覆盖掉默认的无参构造器的原因，因为框架需要以反射机制利用无参构造器创建实例。

# 特点
解耦以及提高代码的灵活性

# 实现原理
java类会在第一次使用时被加载到虚拟机的内存中的方法区中，包含类的属性、方法等信息。
获取Class对象的方法：类名.class，getClass()方法，Class.forName()方法(传入一个全类名，该方法会返回方法区代表这个类型的 Class 对象，如果这个类还没有被加载进方法区，forName 会先进行类加载)。
反射的工作原理就是借助Class.java、Constructor.java、Method.java、Field.java这四个类在程序运行时动态访问和修改任何类的行为和状态。

# 注意
## 反射修改静态变量
对于基本类型的静态常量(final String/int等)，JVM在编译时就会把引用该常量的代码替换为具体的常量值，因此即便通过反射修改了常量的值，也是没意义的。
    修改方法：
    1. 将private final String s = "123"改为private final String s，并在构造方法中对其赋值，可以避免编译时变为常量。因为构造方法是在运行时new 对象才会调用的。这样反射就能起到效果。
    2. 改为private final String s = null == null? "123":null;运行时才会计算的。避免编译时被优化。

## 泛型
java中的泛型是伪泛型，是语法糖，只是在编译时有效，能够在程序运行前提供一定的安全检查，在编译之后，泛型就会被擦除。而反射是在运行时的，也就是说反射调用一个泛型方法，可以绕过编译器的检查，在反射中可以向List<Integer>中存入String类型的元素，因此反射没有编译器这层检查，更容易出现问题。
虽然泛型在编译后会被擦除，但是实际代表该类型的Class类型信息中保存了基本的泛型信息，可以通过反射获取泛型信息。

# 反射性能
## 为什么反射性能差，慢
1. 不使用反射，直接调用时，当访问字段或者方法是直接根据偏移量访问的，在编译的时候就确定了，而反射代码中的访问需要在运行时通过遍历查找。
2. 反射中包含了访问控制的检查，字段或者方法是否可以访问，方法执行时类型检查，而这些在静态代码中是不存在的。
3. JVM虽然对反射进行优化（JIT），但是优化效果没有对静态代码的优化好（反射的有些类型是动态调用，无法优化），比如方法内联就没有在反射中优化。


## 如何提高反射性能
[深入分析Java反射(八)-优化反射调用性能](https://www.throwable.club/2018/12/16/java-reflection-optimal-performance/#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E8%BD%AC%E5%8F%98%E4%B8%BA%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8)
1. 善用API，尽量不要getMethods()后再遍历筛选，而直接用getMethod(methodName)来根据方法名获取方法，避免循环遍历。（getMethod中也是通过遍历得到的）
2. 使用缓存，当多次动态创建一个类的实例时，可以加缓存。可以对Class、Field、Method和Constructor进行缓存。
3. hotspot虚拟机会对执行次数较多的方法进行优化（例如使用jit技术）
4. 反射操作变为直接调用。将反射操作相关的元数据直接放在类的成员变量中，这样能省去从缓存中读取反射相关原属的消耗。
     `有一些高性能的反射类库也会使用一些创新的方法：例如使用成员属性缓存反射相关元数据，并且把方法调用通过数字建立索引[Number->Method]或者建立索引类(像CGLIB的FastClass)，这种做法在父类或者接口方法比较少的时候会有一定的性能提升，但是实际上性能评估需要从具体的场景通过测试分析结果而不能盲目使用，使用这个思想的类库有CGLIB、ReflectASM等`
     动态代理底层的实现也是这样优化的，虽然最终是通过反射调用接口中的方法，但是相关元数据信息在静态代码中创建并且缓存到类（代理类）成员属性中了。

# 应用
[什么样的场景下，需要利用Java的“反射”特性编程？](https://www.zhihu.com/question/66525147)
1. 当需要访问其他类的私有变量和方法时，可以通过反射实现。
2. java的反射特性一般结合注解和配置文件（如：XML）来使用，这也是大部分框架（Spring等）支持两种配置方式的原因。如果是注解方式：当服务端启动时，Spring框架会去扫描指定目录下的类，通过反射看类有没有Service注解，如果类上有 Service注解，会提前初始化（new）这个类。初始化好所有类以后，再去查找所有属性，看属性有没有Autowired注解，有的话，会给这个属性注入值（反射赋值）。如果是XML方式，原理上也差不多，只不过是先解析XML，拿到XML里的配置信息，再去初始化（new）或给属性反射赋值。所以我们写业务代码的时候才不用一个个的去new实现类，所有参数都赋上值，这部分工作Spring已经利用反射技术给完成了。
3. 不同对象之间属性的拷贝。比如BeanUtils.copyProperties()就是通过反射实现的(获取目标对象的属性数组，然后用反射获取原对象该属性的值，再赋值到目标对象)，但是实际中慎用apache的BeanUtils，因为性能很差，可以采用spring自带的BeanUtils或者Cglib BeanCopier(操作字节码，性能会更好，但是创建BeanCopier比较耗时，可以进行缓存或者启动时创建存入缓存中)来代替。
    [Java Bean Copy框架性能对比](https://yq.aliyun.com/articles/392185)
4. spring框架中就是通过反射机制获得bean的Class实例对象。
    `Spring 通过 XML 配置模式装载 Bean 的过程：
    将程序内所有 XML 或 Properties 配置文件加载入内存中
    Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息
    使用反射机制，根据这个字符串获得某个类的Class实例
    动态配置实例的属性
    Spring这样做的好处是：
    不用每一次都要在代码里面去new或者做其他的事情
    以后要改的话直接改配置文件，代码维护起来就很方便了
    有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以通过反射机制来实现`
    