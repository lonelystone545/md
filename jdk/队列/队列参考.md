[TOC]
# BlockingQueue接口
[BlockingQueue接口](https://segmentfault.com/a/1190000016296278)

# ArrayBlockingQueue
[https://segmentfault.com/a/1190000016311925](https://segmentfault.com/a/1190000016311925)
特点：底层依赖数组实现，lock实现线程安全，condition实现阻塞等待，take和put两个指针，实现环形队列。生产者和消费者使用同一把锁，可能在高并发情况下存在一定的性能瓶颈。

# LinkedBlockingQueue
[https://segmentfault.com/a/1190000016315487](https://segmentfault.com/a/1190000016315487)
底层依赖单链表实现的，由于采用Integer类型存储长度信息，因此也是有长度限制的；生产者和消费者采用不同的锁，从而生产者和消费者可以并发执行；对于计数count采用AtomicInteger实现，依赖CAS操作保证生产者和消费者并发修改数据时的安全性。生产者在成功入队一个元素后，如果队列未满，会唤醒其他正在等待的入队线程；然后再需要唤醒消费者（这里需要先获取消费者的锁再进行唤醒）；同样当消费者进行消费时，先获取消费的锁，然后进行出队，如果队列非空，则唤醒其他线程，也会唤醒生产者的线程。

开销：建立Node节点的开销，gc时会产生额外的垃圾回收；生产和消费使用不同的锁，提高并发，但是

# PriorityBlockingQueue
[https://segmentfault.com/a/1190000016353839](https://segmentfault.com/a/1190000016353839)
特点：
1. 无界的阻塞队列，可以指定初始容量，是一种优先级队列，按照权重大小进行出队；
2. 真正的无界队列，仅受内存大小限制；（这里的内存大小其实还是受size限制，为Integer.MAX_VALUE，直接抛出异常了）
3. 队列中的元素必须实现Comparable接口，是可以比较的；或者，初始化时指定Compartor比较器，这时元素可以不需要实现Comparable接口；
4. 底层是基于数组实现的堆结构，大根堆或者小根堆；（经过排序的完全二叉树，父子节点的关系：2 * n + 1，2 * n + 2）
5. 依赖ReentrantLock实现线程安全，只有一个条件队列notEmpty，因为是无界队列，所以插入元素时不会被阻塞；（数组会进行自动扩容，扩容时会释放全局锁，保证扩容和入队和出队可以同时进行，CAS操作变量表示是否正在进行扩容，保证只有一个线程进行扩容，但是当真正进行数组的数据迁移时会加全局锁，此时扩容和入队出队线程只能串行执行；）
6. 添加元素时，元素会进入数组尾部，然后进行元素的上浮操作，以小根堆为例，比较父节点和该元素大小，如果父节点小于该元素，则结束；如果父节点大于该元素，则交换父节点和这个元素，然后递归向上比较父节点即可，最终保证为小根堆；
7. 删除元素时，是删除堆顶的元素，即数组中位置为0的元素，会执行元素下沉的操作，以小根堆为例，会将数组末尾的元素放到数组位置为0的位置作为根元素，然后与孩子节点中较小的进行比较，如果小于，则结束，如果大于，则交换父节点和孩子节点，递归向下比较；
8. PriorityBlockingQueue是线程安全的，加锁了，PriorityQueue是非线程安全的，没有加锁；

堆的详细参考：[优先级队列](https://www.jianshu.com/p/7acd000e9a47)
插入操作：O(lgN) 删除操作：O(lgN)  建堆：O(NlgN) 空间O(NlogN)

# SynchronousQueue
[https://segmentfault.com/a/1190000016359551](https://segmentfault.com/a/1190000016359551)
1. 同步队列，不保存任何元素，也就是说容量是0，数据直接在生产者和消费者线程之间传递，不会将数据缓冲到队列中；（不同于队列长度为1的阻塞队列，它会保存元素）
2. 支持公平和非公平策略，非公平模式采用 栈 数据结构实现，公平模式采用 队列 数据结构实现，栈和队列指的是生产者和消费者线程；
3. 生产者和消费者线程必须一一匹配，否则任意线到达的线程会被阻塞，在栈或者队列中等待，直至有其他线程出现；
4. 采用无锁算法实现的队列，比较轻量，性能比较好，主要是CAS和自旋实现；超过一定自旋次数后才会挂起线程；
5. 应用场景：在CachedThreadPool中的队列使用的就是该队列；

# DelayQueue
[https://segmentfault.com/a/1190000016388106](https://segmentfault.com/a/1190000016388106)
1. 基于PriorityQueue实现，加了lock锁，保证线程安全，condition条件队列进行等待；
2. DelayQueue中的元素需要实现Delayed接口，getDelay方法返回对象的剩余有效时间，只有小于等于0时，才会出队；Delayed接口继承了Comparable接口，使得两个元素能够进行比较，方便排序；
3. 消费者获取元素时，如果队首元素没有过期，则消费者线程会阻塞等待，等待的时间也就是队首元素的剩余有效期；其他消费者线程也会在条件队列中等待，当第一个消费者线程唤醒后且出队成功，它会唤醒条件队列中的下一个线程，然后依次进行限期等待；
4. 主要用于缓存或者定时任务的设计；ScheduledThreadPoolExecutor中用到了；

# ConcurrentLinkedQueue
[https://segmentfault.com/a/1190000016248143](https://segmentfault.com/a/1190000016248143)
1. 使用无锁算法实现的线程安全的队列，依靠自旋和cas来操作；
2. 如果并发竞争比较激烈，那么可能会导致有大量的自旋操作，而且是延迟更新，不是实时的数据一致性；




