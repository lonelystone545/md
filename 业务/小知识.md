# 唯一序列号生成
基于数据库生成的sequence。表中有sequenceName，以及对应的步长，应用服务器会把初始值和步长缓存起来，同时会把初始值更新为加上步长的值，这样其他服务器拿到的就是不同的初始值了。这里利用数据库行锁，select for update，然后再做更新；防止单台服务器并发请求导致获取数据重复，这里加了synchronized锁，保证单台机器只有一个请求从数据库中获取初始值，其他请求则直接从缓存中获取值即可。
高并发场景下，数据库行锁可能成为性能瓶颈，一种解决方案是每个机器有不同的步长，尽量让不同机器在不同时刻请求到数据库更新初始值；或者调大步长的长度；
知识点：数据库行锁，synchronized，ConcurrentHashMap；

# 加解密拦截器
利用mybatis拦截器做的，实现对关键字段加解密的操作；
通过反射获取字段上是否有encryt注解，如果有则进行加密或者解密，由于反射性能比较差，所以会以Class对象作为key，field[]作为value缓存起来，避免每次都进行反射获取属性字段；
知识点：反射，ConcurrentHashMap；

# 分布式锁拦截器等
AOP实现，然后通过反射获取注解，结合spel表达式，解析具体lockKey等；
