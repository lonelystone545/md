# 一次http请求是服务端还是客户端主动关闭连接
http1.1默认是keepalive，即长连接，如果客户端再请求中使用Connection:close，那么服务端在发送完响应后主动关闭连接；

# 四次挥手时，为什么主动关闭的一端要维护TIME_WAIT状态
TIME_WAIT状态属于主动发起关闭连接的一端，当主动关闭的一端也收到了对端的FIN信号时，那么会变为TIME_WAIT状态，然后会在该状态停留2MSL时间，最终变为CLOSED状态。MSL(Mast Segment Live)为一个数据报文在网络中的最大生存时间。任何TCP实现都需要为MSL选择一个值，建议值是2分钟。（每个数据报文都含有一个跳限的8位字端(IPv4的TTL和IPv6的跳限字端)，最大值是255，这是一个跳数限制，而不是真正时间限制，假设具有最呆跳限的分组在网络中存在的时间不会超过MSL）
假设客户端c为主动关闭连接一端，服务端s为被动关闭；
1. 维护TIME_WAIT状态，是为了可靠的实现TCP全双工连接的终止。因为客户端最后发送的ACK可能因为网络原因没有送到服务端，服务端没有收到ACK后，会进行超时重试，重新发送FIN，如果此时客户端关闭了，那么将会响应一个RST包，服务端会认为这是一个错误，上报给系统，虽然也关闭了连接，但是不符合TCP可靠性连接的原则。
2. 如果立刻关闭该连接，这时有一个新的连接过来，ip地址和端口号与刚关闭的连接相同，如果老连接的某个数据包在网络中传输比较久，这个时候到达，会误以为新的连接就是老的连接，那么导致新连接接收到了老连接分组的数据；

通过等待2MSL，保证了某个方向上的分组最多存活MSL被丢弃，另一个方向上的应答最多存活MSL被丢弃，最终保证了老连接在网络中的所有分组都已经在网络中消失了。
为什么是2呢？假如客户端发送ACK刚刚过了一个MSL，而服务端咋收到这个ACK之前刚好进行超时重传FIN，所以等这个FIN消失了，也就是2MSL。

TIME_WAIT状态下发送的ACK丢失，LAST_ACK时刻设定的重传定时器超时，发送重传的FIN，很不幸，这个FIN也丢失，主动关闭方在TIME_WAIT状态等待2MSL没收到任何报文段，进入CLOSED状态，当此时被动关闭方并没有收到最后的ACK。所以即使要主动关闭方在TIME_WAIT状态下停留2MSL，也不一定表示四次握手关闭就一定正常完成。
结论：在TIME_WAIT下等待2MSL，只是为了尽最大努力保证四次握手正常关闭。确保老的报文段在网络中消失，不会影响新建立的连接
[为什么需要2MSL](https://www.zhihu.com/question/67013338)


# RST
表示复位，用来异常的关闭连接。发送端直接丢弃缓冲区的包发送RST包，接收端收到RST包后不需要回复ACK，立即关闭连接。TCP程序会在自己认为异常的时候发送RST包，比如，A向B发送，但是B上无相应的监听端口，这时B系统的TCP程序会发送RST包

# 四元组
包含源IP 源端口 目标IP 目标端口；通过四元组可以唯一的确定一个连接。
B作为服务端，IP和端口是公开的，只需要知道A的端口和IP就可以发送RST攻击，伪造的序列号需要在滑动窗口范围内。

# 应用中出现大量的closed_wait状态
https://www.11taotao.com/post/87.html
