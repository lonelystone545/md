[TOC]
# 背景
如何实现延时触发或者定时器呢？
比如订单超时30分钟自动关闭，订单10分钟未付款则通知用户，30s内连接空闲则关闭连接等；
# 技术方案
## 定时扫描所有超时事件
如果可以允许一秒左右的误差，可以每隔一秒轮训一次即可。
缺点：
1. 在轮训的时候很多情况下没有可触发的任务，浪费资源；
2. 如果任务数量很大，那么会有一些延迟，不能保证一秒的误差；
3. 任务会被重复的扫描；

* 改进方案
采用红黑树或者最小堆存储定时任务，按照触发的时间戳进行排序，这样每次扫描能够很快获取即将超时的任务。插入和删除操作的平均时间复杂度O(logn)。

## Redis实现
使用Redis的SortedSet存储定时任务，使用zrangeByScore获取超时任务，再使用zremrangeByScore删除可触发的任务。由于是两条指令，如果是多线程执行任务需要注意并发问题，否则任务会重复执行。
如果不关注消费者的高可用（一个队列的消费线程挂了会有其他线程接管），那么最简单的实现就是使用单线程消费，通过多Redis队列分片来提升消费速度。而如果关注消费者的高可用，可以选择Redisson中的RDelayedQueue以及Jesque，它们通过使用Redis Lua实现了并发控制，支持多线程消费。

## 阻塞线程等待超时
方案思路来自于Nginx中定时器的实现（和Java中的DelayQueue原理类似）。任务的存储和上面的方案类似，采用最小堆或者红黑树即可。然后选择最近要被触发的任务的时间距离作为阻塞调用epoll_wait的超时（也可以使用其他可以设置超时的阻塞调用）。阻塞超时后，依次获取最小触发时间戳的任务，超时则执行。
此种方案的最大优点在于不会有空的任务检查周期，插入和删除操作的平均时间复杂度和方案一一样是O(logn)。
实践中，给DelayQueue实现持久化机制即可。
参考:
[DelayQueue实现订单超时](https://my.oschina.net/u/3081871/blog/1790780/)

## 环形队列
[实现原理](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959961&idx=1&sn=afec02c8dc6db9445ce40821b5336736&chksm=bd2d07458a5a8e5314560620c240b1c4cf3bbf801fc0ab524bd5e8aa8b8ef036cf755d7eb0f6)
[定时器的几种实现方式](https://juejin.im/post/5c4d3d1af265da6151151846)
[代码实现](https://blog.51cto.com/wenshengzhu/2106623)
核心原理：将环形队列(本质上是数组)切分为3600个slot，每个slot存储定时任务的集合Set<Task>，定时任务每隔一秒扫描一个slot，通过向后移动curIndex指针，该指针指向当前扫描的slot。然后检查slot中的定时任务集合是否现在执行，依据是，Task有一个关键参数，cycleNum表示圈数，为0时才会触发定时任务，否则cycleNum-=1；将任务添加到环形队列时需要跟进当前的curIndex和事件延迟触发的时间来计算cycleNum和slot位置。
假设一个任务Ts后执行，那么slot = T % 3600 + curIndex，cycleNum = T / 3600。
插入和删除的时间复杂度为O(1)。
该方案将大量的任务拆分为3600份，每次只需要检查一份中的任务集合，数量明显会少很多，因此实效性也会很好。但是同样存在每次扫描可以为空任务的问题，性能影响小，可忽略。
Netty中的HashedWheelTimer采用的就是该方案。(问题：1 存在cpu空转 2 如果单个任务执行时间太长，会导致后面的任务执行时间不准确，单线程执行)
Kafka使用的DelayQueue+分层时间轮的方案。这种方案使用DelayQueue避免了空轮训的问题，同时分层的方式能够减少每一个slot存放任务过多的问题。
`当时间跨度很大时，提升单层时间轮的 tickDuration 可以减少空转次数，但会导致时间精度变低，层级时间轮既可以避免精度降低，又避免了指针空转的次数。如果有时间跨度较长的定时任务，则可以交给层级时间轮去调度。
设想一下一个定时了 3 天，10 小时，50 分，30 秒的定时任务，在 tickDuration = 1s 的单层时间轮中，需要经过：3246060+106060+5060+30 次指针的拨动才能被执行。但在 wheel1 tickDuration = 1 天，wheel2 tickDuration = 1 小时，wheel3 tickDuration = 1 分，wheel4 tickDuration = 1 秒 的四层时间轮中，只需要经过 3+10+50+30 次指针的拨动。`
参考:
[kafka解惑之时间轮](https://blog.csdn.net/u013256816/article/details/80697456)
[如何让快递更"快"？菜鸟自研定时任务调度引擎首次公开](https://mp.weixin.qq.com/s/QxV4-sa72ALCZdD4QWqLPA)


## 延时消息队列
RabbitMQ和RocketMQ都支持延时消息队列。RabbitMQ是通过TTL实现的，RocketMQ的延迟时间是预定义的，不够灵活。
支持消费者ACK，可靠性高。

# 注意事项
对于内存中的任务队列，如果机器挂了，如何处理？
所以，应该将内存中的任务队列做持久化，当机器启动后，将数据库中还处于排队的任务加载到内存中等待执行。但是对于环形队列来说，可能挂了后，任务重新加载进来就已经超过时间了，需要分具体业务场景来选择不同的方案，或者在Task中添加其他的参数如执行的时间戳，每次执行任务时都比较一下当前时间戳和执行时间戳。

# 方案选择
1. 如果应用中已有RabbitMQ或者追求消费的高可靠性，推荐RabbitMQ。
2. 简单使用，数据量不大，对高可用、任务消费可靠性要求不高的情况下，可以选择单线程轮询数据库或者Redis方案。
3. 数据量较大、关注消费速度和高可用、对任务消费的可靠性要求不高，推荐使用Jesque/RDelayedQueue。