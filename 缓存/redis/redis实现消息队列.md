[TOC]
# 为什么用redis实现消息队列
当需要实现系统间解耦、异步或者削峰填谷时，且当前生产环境没有额外的资源搭建MQ服务器，这时可以用redis实现一个轻量级的消息队列(一般来说，生产环境都是有缓存服务redis的)

# redis实现消息队列的方案
## List结构实现
redis中的list是一个双端链表，且支持阻塞式弹出。即lpop入队，brpop阻塞式弹出元素。
brpop：当给定列表中没有任何元素时，连接会被brpop命令阻塞，直至等待超时或者发现可弹出的元素；当给定了多个key参数时，按照参数key的先后顺序依次检查各个列表，弹出第一个非空队列的尾部元素。
## 发布/订阅模式
消费者订阅某个channel，生产者将消息发发送给订阅该channel的所有消费者。如果没有消费者，则消息会丢失，未提供消息持久化的支持。
发布者：无需独占链接，在发布消息的同时，可以做其他操作；
订阅者：需要独占链接，在订阅期间，以阻塞方式等待消息到达；TCP默认的连接时间固定，如果期间连接上无任何数据传输，那么会强制收回该连接。可以采用定时器来模拟pub和sub之间的保活机制，定时器时间不能超过TCP的最大连接时间。

* 业务实现持久化
    1. redis的set集合中新增 订阅者ID，保存了活跃订阅者；
    2. subcribe端开启订阅操作后，需要在redis中创建一个以 订阅者ID 为key的list数据结构，list中存储了所有尚未消费的消息；
    3. publish端发布一条消息后，publish端需要遍历 活跃订阅者集合，依次向每个list尾部追加此次发送的消息；
    4. 到此为止，基本可以保证每一条消息都能持持久保存在 list 中；
    5. subcribe端收到消息后，消费完成后必须删除自己的 list 的头部一条记录；
    6. subcribe端优先消费自己的 list 中的消息；

# redis消息队列的注意事项
1. 对于pub/sub模式，生产者将消息发送给redis，如果此时没有消费者订阅，那么消息会丢失。
2. pub/sub模式不是一种可靠的消息系统，当客户端连接退出，或者极端情况下服务端发生主备切换时，未消费的消息会被丢弃。
3. pub/sub是一对多，所有消费者都能够获取消息，无法通过增加消费者数量来增加消费速度。
4. 没有ack机制，可靠性无法保证。
5. list实现的队列无法做到一对多。

# 延迟队列实现
[延迟队列实现(有github)](https://www.jianshu.com/p/e958e8590020)
[有赞延迟队列实现](https://tech.youzan.com/queuing_delay/)