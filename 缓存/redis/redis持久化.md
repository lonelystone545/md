执行BGSAVE命令或者BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）来优化子进程的使用效率，所以在子进程存在期间，服务器会提高负载因子的阈值，从而避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入操作，最大限度地节约内存。

# 持久化
## RDB
RDB持久化方式是通过快照(snapshotting)完成的，当符合一定条件时，redis会自动将内存中所有数据以二进制方式生成一份副本并存储在硬盘上。当redis重启时，并且AOF持久化未开启时，redis会读取RDB持久化生成的二进制文件(默认名称dump.rdb，可通过设置dbfilename修改)进行数据恢复，对于持久化信息可以用过命令“info Persistence”查看。

快照触发条件
RDB生成快照可自动促发，也可以使用命令手动触发，以下是redis触发执行快照条件，后续会对每个条件详细说明：
1. 客户端执行命令save(阻塞redis)和bgsave(fork子进程,fork操作是阻塞redis主进程的)会生成快照；
2. 根据配置文件save m n规则进行自动快照；
3. 主从复制时，从库全量复制同步主库数据，此时主库会执行bgsave命令进行快照；
4. 客户端执行数据库清空命令FLUSHALL时候，触发快照；
5. 客户端执行shutdown关闭redis时，触发快照；

## AOF
当redis存储非临时数据时，为了降低redis故障而引起的数据丢失，redis提供了AOF(Append Only File)持久化，从单词意思讲，将命令追加到文件。AOF可以将Redis执行的每一条写命令追加到磁盘文件(appendonly.aof)中,在redis启动时候优先选择从AOF文件恢复数据。由于每一次的写操作，redis都会记录到文件中，所以开启AOF持久化会对性能有一定的影响，但是大部分情况下这个影响是可以接受的，我们可以使用读写速率高的硬盘提高AOF性能。与RDB持久化相比，AOF持久化数据丢失更少，其消耗内存更少(RDB方式执行bgsve会有内存拷贝)。

redis将每一条写命令以redis通讯协议添加至缓冲区aof_buf,这样的好处在于在大量写请求情况下，采用缓冲区暂存一部分命令随后根据策略一次性写入磁盘，这样可以减少磁盘的I/O次数，提高性能。
当写命令写入aof_buf缓冲区后，redis会将缓冲区的命令写入到文件，redis提供了三种同步策略，由配置参数appendfsync决定，下面是每个策略所对应的含义：
1. no：不使用fsync方法同步，而是交给操作系统write函数去执行同步操作，在linux操作系统中大约每30秒刷一次缓冲。这种情况下，缓冲区数据同步不可控，并且在大量的写操作下，aof_buf缓冲区会堆积会越来越严重，一旦redis出现故障，数据丢失严重。
2. always：表示每次有写操作都调用fsync方法强制内核将数据写入到aof文件。这种情况下由于每次写命令都写到了文件中, 虽然数据比较安全，但是因为每次写操作都会同步到AOF文件中，所以在性能上会有影响，同时由于频繁的IO操作，硬盘的使用寿命会降低。
3. everysec：数据将使用调用操作系统write写入文件，并使用fsync每秒一次从内核刷新到磁盘。 这是折中的方案，兼顾性能和数据安全，所以redis默认推荐使用该配置。


当开启的AOF时，随着时间推移，AOF文件会越来越大,当然redis也对AOF文件进行了优化，即触发AOF文件重写条件时候，redis将使用bgrewriteaof对AOF文件进行重写。这样的好处在于减少AOF文件大小，同时有利于数据的恢复。

* 重写原理
AOF文件随着时间的增加，导致AOF文件越来越大，而且从AOF文件中恢复数据时也会变慢很多。通过重写AOF文件，能够使AOF文件的体积变小，且新旧两个文件保存的数据库状态是相同的。重写是根据redis数据库当前的状态进行的，不会使用原来的aof文件。

首先从数据库中读取键现在的值，然后用一条命令记录键值对，代替之前的多个命令；同时为了避免客户端输入缓冲区溢出，重写程序在处理大集合时，如果元素数量超过阈值，那么重写程序会采用多条命令来记录键的值，而不是单一命令；

* 数据一致问题
    子进程在aof重写时，主进程继续处理客户端的命令请求，新的命令可能对现有的数据进行修改，会导致当前数据和重写后的AOF文件数据不一致。
    为了解决数据不一致的问题，redis增加了一个AOF重写缓存。redis主进程在处理客户端写命令后，同时将这个命令追加到AOF缓冲区(现有的AOF文件，即不会影响现有的AOF操作)和AOF重写缓冲区。
    那么在完成AOF文件重写后，子进程会向父进程发送一个完成的信号，父进程收到这个信号后，会将AOF重写缓存中的内容全部写入到新的AOF文件中，这时AOF文件保存的数据库状态和服务器当前的数据库状态是一致的；然后对新的AOF文件进行改名，原子覆盖原有的AOF文件，从而完成新旧两个文件的替换。当主进程处理完成后，主进程就可以继续像往常一样接收命令请求了。
    
* AOF重写会阻塞主进程么？
    1. 主进程fork子进程时会阻塞主进程，由于采用了COW机制，速度很快；
    2. 子进程重写AOF完成后，主进程会将重写缓冲区的内容写到新的AOF缓存中，这个会阻塞；(如果缓冲区内容比较多，那么阻塞时间很长，子进程可以先将重写缓冲区写到aof缓存中，这个时间很短，期间产生的脏数据也少，最后再由主进程负责写)
    3. 主进程对新的AOF文件改名，原子的覆盖原有的AOF文件，完成新旧两个文件替换。

## 问题
当同时开启aof和rdb时，在恢复数据时，优先从aof文件中恢复数据，如果aof文件不存在，才会从rdb文件中恢复数据，因为aof能够丢失更少的数据。

redis默认采用rdb的持久化方式，如果贸然改成aof，重启后会读取aof文件，但是此时aof文件是空的，则导致redis被清空。
解决：改为aof后，手动执行bigrewriteaof操作，将内存中的内容记录到aof文件中即可。

## 混合持久化
rdb容易丢失两次快照之间的数据，但是当redis重启后从rdb快照中恢复数据也是很快的；aof最多丢失1s的数据，但是重启后从aof文件中恢复数据比较慢(因为是存储redis写命令的)；
redis4.0添加了混合持久化方式，结合aof和rdb优点，快速恢复数据的同时，避免丢失过多数据，缺点是aof里面的rdb数据是压缩格式不再是aof格式，可读性差。

默认是关闭的，通过aof-use-rdb-preamble配置参数控制，yes则表示开启，no表示禁用，默认是禁用的，可通过config set修改。

混合持久化同样也是通过bgrewriteaof完成的，不同的是当开启混合持久化时，fork出的子进程先将共享的内存副本全量的以RDB方式写入aof文件，然后在将重写缓冲区的增量命令以AOF方式写入到文件，写入完成后通知主进程更新统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件。简单的说：新的AOF文件前半段是RDB格式的全量数据后半段是AOF格式的增量数据。

我们开启了混合持久化时，启动redis依然优先加载aof文件，aof文件加载可能有两种情况如下：

aof文件开头是rdb的格式, 先加载 rdb内容再加载剩余的 aof。
aof文件开头不是rdb的格式，直接以aof格式加载整个文件。

## 优缺点
* RDB
优点：

RDB 是一个非常紧凑（compact）的文件，体积小，因此在传输速度上比较快，因此适合灾难恢复。 

RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。

RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。

缺点：

RDB是一个快照过程，无法完整的保存所以数据，尤其在数据量比较大时候，一旦出现故障丢失的数据将更多。
当redis中数据集比较大时候，RDB由于RDB方式需要对数据进行完成拷贝并生成快照文件，fork的子进程会耗CPU，并且数据越大，RDB快照生成会越耗时。
RDB文件是特定的格式，阅读性差，由于格式固定，可能存在不兼容情况。

* AOF　
优点：

数据更完整，秒级数据丢失(取决于设置fsync策略)。
兼容性较高，由于是基于redis通讯协议而形成的命令追加方式，无论何种版本的redis都兼容，再者aof文件是明文的，可阅读性较好。
缺点：

数据文件体积较大,即使有重写机制，但是在相同的数据集情况下，AOF文件通常比RDB文件大。
相对RDB方式，AOF速度慢于RDB，并且在数据量大时候，恢复速度AOF速度也是慢于RDB。
由于频繁地将命令同步到文件中，AOF持久化对性能的影响相对RDB较大，但是对于我们来说是可以接受的。

* 混合持久化
优点：

混合持久化结合了RDB持久化 和 AOF 持久化的优点, 由于绝大部分都是RDB格式，加载速度快，同时结合AOF，增量的数据以AOF方式保存了，数据更少的丢失。
缺点：

兼容性差，一旦开启了混合持久化，在4.0之前版本都不识别该aof文件，同时由于前部分是RDB格式，阅读性较差





# COW机制
## fork
fork函数是uninx操作系统创建进程的主要方法，fork用于创建子进程，等同于当前进程的副本。新的进程需要通过复制老的进行得到。
## exec函数
exec函数的作用就是：装载一个新的程序（可执行映像）覆盖当前进程内存空间中的映像，从而执行不同的任务。exec系列函数在执行时会直接替换掉当前进程的地址空间。

## COW
### 解释
传统的做法，在fork时，会直接将父进程的数据拷贝到子进程，拷贝完成之后，父进程和子进程的数据段、堆段是相互独立的，经验来看，子进程一般都会执行exec函数来执行自己的功能，那么会清空拷贝过来的数据，创建一个新的内存空间，可见，此时的拷贝是无用功，只会增加fork的时间；

COW即写时复制，fork创建出来的子进程，不会立即为子进程分配新的内存空间(如建立页表，拷贝父进程的内存空间等)，fork之后的子进程和父进程共享一个地址空间，只有当父子进程对内存进行修改时，kernel才会复制一份内存空间(只是复制修改的页)。
COW目的是为了加速fork的调用，同时也减少无效的内存拷贝。

### redis应用
可以通过bigsave(rdb快照)或者bigrewriteaof(重写aof文件)命令触发fork操作，fork子进程负责内存持久化到磁盘。如果在持久化过程，redis仅仅是读的操作，那么不会发生父子进程的拷贝；如果此时发生了写操作，那么一边写内存，一边把内存中的内容写到磁盘上，会有一致性问题。通过cow机制，redis的父进程在处理写请求时，那么会拷贝原先的内存页面，然后执行写请求，而fork出来的子进程读取的还是原先的内存页，也就是说此时修改对于子进程是不可见的。

redis的读操作比较多，如果子进程存在期间，发生大量的写，那么会耗费不少性能在复制脏页上。rehash阶段，写操作无法避免，所以redis在fork子进程后，将负载因子提高，尽量减少些操作，避免不必要的内存操作，最大限度节约内存。

### JDK应用
CopyOnWriteArrayList
CopyOnWriteArraySet

### 原理
fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。
1. 谁修改内存，谁持有复制品。
2. copy的大小是页的大小。

### 利弊
优点：
1. cow技术不需要在fork时将父进程的内存拷贝到子进程，因此可以减少分配和复制大量资源带来的瞬间延时，减少fork时间；
2. 减少不必要的资源分配，比如fork进程时，不是所有的页面都需要复制，父进程的代码段和只读段数据不允许修改，所以无需复制。

缺点：
如果在fork之后，父子进行都还需要进行写操作，那么会产生大量的分页错误，这样就得不尝失；

