# 发布订阅原理
[订阅与发布](https://redisbook.readthedocs.io/en/latest/feature/pubsub.html)
redis中有类似key-value结构，key为channel，value为订阅该channel的订阅者，是一个链表。

# lazyfree机制
## 为什么需要lazyfree
`redis重度使用患者应该都遇到过使用 DEL 命令删除体积较大的键， 又或者在使用 FLUSHDB 和 FLUSHALL 删除包含大量键的数据库时，造成redis阻塞的情况；另外redis在清理过期数据和淘汰内存超限的数据时，如果碰巧撞到了大体积的键也会造成服务器阻塞。测试来看，删除一个100万个元素的集合键，耗时约1000ms左右。
为了解决以上问题， redis 4.0 引入了lazyfree的机制，它可以将删除键或数据库的操作放在后台线程里执行， 从而尽可能地避免服务器阻塞。`
在redis4.0前，没有lazy free功能；DBA只能通过取巧的方法，类似scan big key,每次删除100个元素；但在面对“被动”删除键的场景，这种取巧的删除就无能为力。
例如：我们生产Redis Cluster大集群，业务缓慢地写入一个带有TTL的2000多万个字段的Hash键，当这个键过期时，redis开始被动清理它时，导致redis被阻塞20多秒，当前分片主节点因20多秒不能处理请求，并发生主库故障切换。
redis4.0有lazy free功能后，这类主动或被动的删除big key时，和一个O(1)指令的耗时一样,亚毫秒级返回； 把真正释放redis元素耗时动作交由bio后台任务执行。


## 支持的指令
lazyfree的原理就是在删除对象时，只是进行逻辑的删除，然后由后台线程去执行真正的对象删除操作，避免由于对象体积过大而造成阻塞。lazyfree支持的命令如下：
1. uunlink
`首先定义了启用后台删除的阈值，对象中的元素大于该阈值时才真正丢给后台线程去删除，如果对象中包含的元素太少就没有必要丢给后台线程，因为线程同步也要一定的消耗。`
异步删除时，首先清除key的过期时间，然后把要删除对象从字典中删除(逻辑删除，数据库字典维护了redis中的所有key-value)，这样下次查询时就查不到该key了，再判断对象的大小，如果大于后台删除的阈值，才会异步删除，否则立即删除。
对于体积较大的对象由后台线程完成，所以不会阻塞redis主线程。
2. flushall，flushdb
redis4.0给flush命令新增了选项 async，当flus类命令后面带有async时，就会进入后台删除；

## lazyfree线程
首先要澄清一个误区，很多人提到redis时都会讲这是一个单线程的内存数据库，其实不然。虽然redis把处理网络收发和执行命令这些操作都放在了主工作线程，但是除此之外还有许多bio后台线程也在兢兢业业的工作着，比如用来处理关闭文件和刷盘这些比较重的IO操作，这次bio家族又加入了新的小伙伴——lazyfree线程。
lazyfree线程是真正执行删除操作的线程；
1. 后台删除对象，调用decrRefCount来减少对象的引用计数，引用计数为0时会真正的释放资源。
2. 后台清空数据库字典，调用dictRelease循环遍历数据库字典删除所有对象；
3. 后台删除key-slots映射表，原生redis如果运行在集群模式下会用，云redis使用的自研集群模式这一函数目前并不会调用。

## 过期与逐出
redis的expire也有可能阻塞redis操作的。在redis4.0中增加以下配置支持是否异步删除；
```xml
slave-lazy-flush：slave接收完RDB文件后清空数据选项
lazyfree-lazy-eviction：内存满逐出选项
lazyfree-lazy-expire：过期key删除选项
lazyfree-lazy-server-del：内部删除选项，比如rename srckey destkey时，如果destkey存在需要先删除destkey
```
以上4个选项默认为同步删除，可以通过config set [parameter] yes打开后台删除功能。

### lazyfree-lazy-evivtion
针对redis内存使用达到maxmeory，并设置有淘汰策略时；在被动淘汰键时，是否采用lazy free机制；
因为此场景开启lazy free, 可能使用淘汰键的内存释放不及时，导致redis内存超用，超过maxmemory的限制。此场景使用时，请结合业务测试。
### lazyfree-lazy-expire
针对设置有TTL的键，达到过期后，被redis清理删除时是否采用lazy free机制；
此场景建议开启，因TTL本身是自适应调整的速度。
### lazyfree-lazy-server-del
针对有些指令在处理已存在的键时，会带有一个隐式的DEL键的操作。如rename命令，当目标键已存在,redis会先删除目标键，如果这些目标键是一个big key,那就会引入阻塞删除的性能问题。 此参数设置就是解决这类问题，建议可开启。

### slave-lazy-flush
针对slave进行全量数据同步，slave在加载master的RDB文件前，会运行flushall来清理自己的数据场景，
参数设置决定是否采用异常flush机制。如果内存变动不大，建议可开启。可减少全量同步耗时，从而减少主库因输出缓冲区爆涨引起的内存使用增长。

## expire优化
redis在空闲时会进入activeExpireCycle循环删除过期key，每次循环都会率先计算一个执行时间，在循环中并不会遍历整个数据库，而是随机挑选一部分key查看是否到期，所以有时时间不会被耗尽（采取异步删除时更会加快清理过期key），剩余的时间就可以交给freeMemoryIfNeeded来执行。

# redis pipeline
[redis的事务与管道](https://blog.csdn.net/qq_35923749/article/details/85252043)
Redis 的工作过程是基于 请求/响应 模式的。正常情况下，客户端发送一个命令，等待 Redis 应答；Redis 接收到命令，处理后应答。请求发出到响应的时间叫做往返时间，即 RTT（Round Time Trip）。在这种情况下，如果需要执行大量的命令，就需要等待上一条命令应答后再执行。这中间不仅仅多了许多次 RTT，而且还频繁的调用系统 IO，发送网络请求。为了提升效率，pipeline 出现了，它允许客户端可以一次发送多条命令，而不等待上一条命令执行的结果。
实现思路
客户端首先将执行的命令写入到缓冲区中，最后再一次性发送 Redis。但是有一种情况就是，缓冲区的大小是有限制的：如果命令数据太大，可能会有多次发送的过程，但是仍不会处理 Redis 的应答。

实现原理
要支持 pipeline，既要服务端的支持，也要客户端支持。对于服务端来说，所需要的是能够处理一个客户端通过同一个 TCP 连接发来的多个命令。可以理解为，这里将多个命令切分，和处理单个命令一样。对于客户端，则是要将多个命令缓存起来，缓冲区满了就发送，然后再写缓冲，最后才处理 Redis 的应答。

pipeline不能保证所有的命令全部成功或者失败，当有失败时，可以从后面的返回结果得知。

# redis内存回收和内存共享
C语言不具备自动回收内存的功能。redis自己构建了一个内存回收机制，redisObject对象中有个refCount属性，表示被引用的次数；当创建一个对象时，refCount初始化为1，对象被程序使用时，refCount加1，不再被一个程序使用时，refCount减1；当引用计数变为0时，对象占用的内存会被释放。
无法解决 循环引用问题。那么redis如何解决呢？可以配置不同的回收策略如lru，random等算法，对内存进行回收。如何进行lru呢？在redisObject中有个属性记录了对象最后一次被访问的时间戳，通过OBJECT IDLETIME key得到一个key的空转时长(当前时间-lru)，优先删除空转时间最长的对象。

Redis的共享对象目前只支持整数值的字符串对象。之所以如此，实际上是对内存和CPU（时间）的平衡：共享对象虽然会降低内存消耗，但是判断两个对象是否相等却需要消耗额外的时间。对于整数值，判断操作复杂度为O(1)；对于普通字符串，判断复杂度为O(n)；而对于哈希、列表、集合和有序集合，判断的复杂度为O(n^2)。
将键指向一个现有值的对象，将共享对象的refCount加1。