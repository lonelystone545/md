[TOC]
# 背景
redis是单线程执行的，所有的读写操作都是在主线程中执行，如果一条命令执行时间太长，那么会导致其他命令阻塞排队，影响整体性能。
# 如何发现
1. 客户端监控方法耗时，包含了网络IO+redis排队延时+redis命令执行时间
2. 服务端通过slow log进行监控，只会记录执行时间的慢查询(可以通过慢查询推测是否有阻塞)
3. info命令查看阻塞的客户端连接数
4. 查看redis连接池的连接数是否满，未满也有可能存在大key执行耗时导致阻塞；
5. review代码

# 阻塞原因
## key设计不合理
redis4.0以前，del的时间复杂度是O(N)，如果删除大key的集合，那么会非常耗时；
优化：分批删除，每次scan一部分数据，然后再删除；redis4.0后可以惰性删除，即子线程去处理；
1. 如何发现： slowlog get {n} 获取最近的n条慢查询命令，默认是对超过10ms的命令记录在定长队列中，满了则丢弃最早的慢查询命令；生产环境调整为1ms；
2. 如何调整： 调整数据结构或者key的设计，将大key拆分为多个小key
    * 需要整存整取
      分拆成多个key-value，使用multiGet获取值；这样，将操作的压力由一个redis实例分摊到多个redis实例中，降低对单个redis的IO影响；
    * 存取部分数据
      分拆成多个子key-value，存储在hash结构中，使用hget/hmget来获取部分的value；hset/hmset更新部分数据；
      newKey = hash(oldKey) % m (m为分子key的数量)
3. 如何发现大对象 redis-cli -h {ip} -p {port} --bigkeys
   不是按照实际占用内存大小，对于string是length，对于集合是size；
   内部是采用SCAN操作，SCAN是增量式的迭代，每次执行只会返回少量元素，因此可以用于生产环境;(keys/smembers命令用于处理大key时，可能会阻塞服务器几秒);
   增量式迭代的问题：在对key进行增量式迭代时，键可能会被修改，所以增量式迭代命令只能对返回的元素提供有限的保证；
   SCAN是一个基于游标的迭代器，每次调用后都会返回给用户一个新的游标，用户在下次迭代时使用这个新的游标作为SCAN命令参数即可。游标参数为0时，将开始一次新的迭代；而服务器返回游标为0时，表示迭代结束；[SCAN命令详解](http://doc.redisfans.com/key/scan.html)
## CPU饱和
单核cpu利用率接近100%，会导致redis无法处理更多的命令，影响吞吐量和稳定性。需要判断当前redis的并发量是否达到极限，redis-cli -h {ip} -p {port} --stat获取当前Redis使用情况;
## 持久化阻塞
* fork阻塞：开启rdb持久化/AOF日志重写/master首次向slave同步数据，redis会fork一个子进程来做持久化操作，采用了操作的copy-on-write写时复制的策略，子进程和父进程共享page。如果父进程的page有修改，那么父进程自己创建page的副本，不会影响子进程。虽然共享数据的内容不会复制，但是需要复制之前进程空间的内存页表（每个进程都有页表，存放逻辑地址和物理地址的映射关系），这个需要时间； 
* AOF刷盘阻塞：子进程执行AOF重写或者RDB持久化，redis服务设置了appendfsync everysec, 主进程每秒钟便会调用 fsync(),每秒对AOF文件做fsync操作；此时如果IO操作的量比较大，会阻塞主进程；===》 解决：设置 no-appendfsync-on-rewrite yes, 在子进程执行AOF重写时, 主进程不调用fsync()操作；注意, 即使进程不调用 fsync(), 系统内核也会根据自己的算法在适当的时机将数据写到硬盘(Linux 默认最长不超过 30 秒). 
  这个设置带来的问题是当出现故障时，最长可能丢失超过30秒的数据，而不再是1秒
* HugePage写操作阻塞：子进程在执行重写期间利用Linux写时复制技术降低内存开销，因此只有写操作时Redis才复制要修改的内存页。对于开启Transparent HugePages的操作系统，每次写命令引起的复制内存页单位由4K变为2MB，放大了512倍，会拖慢写操作的执行时间，导致大量写操作慢查询。Linux 内核默认启用了透明大页来管理内存。

## CPU竞争
进程竞争：Redis是典型的CPU密集型应用，不建议和其他多核CPU密集型服务部署在一起。当其他进程过度消耗CPU时，将严重影响Redis吞吐量。可以通过top、sar等命令定位到CPU消耗的时间点和具体进程，这个问题比较容易发现，需要调整服务之间部署结构。
绑定CPU：部署Redis时为了充分利用多核CPU，通常一台机器部署多个实例。常见的一种优化是把Redis进程绑定到CPU上，用于降低CPU频繁上下文切换的开销。这个优化技巧正常情况下没有问题，但是存在例外情况，当Redis父进程创建子进程进行RDB/AOF重写时，如果做了CPU绑定，会与父进程共享使用一个CPU。子进程重写时对单核CPU使用率通常在90%以上，父进程与子进程将产生激烈CPU竞争，极大影响Redis稳定性。因此对于开启了持久化或参与复制的主节点不建议绑定CPU。
## 内存交换
内存交换（swap）对于Redis来说是非常致命的，Redis保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把Redis使用的部分内存换出到硬盘，由于内存与硬盘读写速度差几个数量级，会导致发生交换后的Redis性能急剧下降。
预防内存交换：
保证机器充足的可用内存。
确保所有Redis实例设置最大可用内存（maxmemory），防止极端情况下Redis内存不可控的增长。
降低系统使用swap优先级。

   
   
        