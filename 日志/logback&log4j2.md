[性能比较](https://blog.souche.com/logback-log4j-log4j2shi-ce/)
log4j2性能优于logback，内部采用不加锁的disruptor。
多线程写日志文件的时候，需要加锁处理，线程安全性问题。但是如果改为异步的话，加锁的性能影响可以忽略。

disrupter是一个高性能的队列，主要是为了解决传统队列加锁引起的性能差问题，它之所以性能高的原因：
1. 无锁实现，采用CAS操作，内部维护了一个ringbuffer，即环形数组，和自增的sequence，当多线程插入的时候cas增加序列号，然后填入不同的位置，同样维护了一个相同的数组，当有数据时会把相应位置置位，多线程获取数据时也有自己的sequence来获取不同位置的元素；
2. 通过缓存行填充解决了伪共享问题。伪共享是由多个cpu核引起的，每个cpu都有自己的告诉缓存，当从主内存中获取数据时，会将该数据相邻的64字节长度的数据一起缓存起来，即缓存行，但是相邻的数据不一定都是由当前cpu使用到的，可能自己不使用的数据被其他cpu使用再更新，由于内存屏障的存在，那么会导致cpu的缓存都失效，不得不从主内存中获取数据。比如cpu1和cpu2分别运行线程1和2，线程1用到了数据a，线程2用到了数据b，但是cpu1和2都缓存了a和b，那么当线程2修改数据b后，也会引起cpu1的缓存行失效，但是cpu1的线程只用到了数据a，但是由于内存屏障的原因，不得不去主内存重新获取数据，同理线程1修改数据a也会影响线程2的缓存，这个就是伪共享问题。如何解决呢？既然从内存中拉取64字节的数据缓存，那么只需要把用到的数据周围进行填充为null就行了，比如sequence进行填充。
3. 支持多线程和单线程两种模式，单线程采用long实现sequence，多线程采用atomicLong实现。cas也会存在竞争和自旋问题。